import * as THREE from 'three'
import type { ExportParams } from '@/types'

/**
 * Error class for OBJ export operations
 */
export class OBJExportError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'OBJExportError'
  }
}

/**
 * Utility class for exporting Three.js meshes to OBJ format
 */
export class OBJExporter {
  /**
   * Export a Three.js mesh to OBJ format string
   */
  static exportToOBJ(mesh: THREE.Group, params: ExportParams): string {
    try {
      const vertices: THREE.Vector3[] = []
      const normals: THREE.Vector3[] = []
      const faces: Array<{ vertices: number[]; normals: number[] }> = []
      
      let vertexIndex = 1 // OBJ format uses 1-based indexing
      let normalIndex = 1
      
      // Process all meshes in the group
      mesh.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          this.processMesh(child, vertices, normals, faces, vertexIndex, normalIndex, params.scaleFactor)
          
          const positionCount = child.geometry.attributes.position?.count || 0
          const normalCount = child.geometry.attributes.normal?.count || 0
          
          vertexIndex += positionCount
          normalIndex += normalCount
        }
      })
      
      // Generate OBJ content
      let objContent = '# Generated by Dot Art 3D Converter\n'
      objContent += `# Vertices: ${vertices.length}\n`
      objContent += `# Faces: ${faces.length}\n\n`
      
      // Write vertices
      for (const vertex of vertices) {
        objContent += `v ${vertex.x.toFixed(6)} ${vertex.y.toFixed(6)} ${vertex.z.toFixed(6)}\n`
      }
      
      objContent += '\n'
      
      // Write normals
      for (const normal of normals) {
        objContent += `vn ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`
      }
      
      objContent += '\n'
      
      // Write faces
      for (const face of faces) {
        objContent += 'f '
        for (let i = 0; i < face.vertices.length; i++) {
          objContent += `${face.vertices[i]}//${face.normals[i]} `
        }
        objContent += '\n'
      }
      
      return objContent
      
    } catch (error) {
      throw new OBJExportError(
        `Failed to export to OBJ: ${error instanceof Error ? error.message : 'Unknown error'}`
      )
    }
  }
  
  /**
   * Process individual mesh for OBJ export
   */
  private static processMesh(
    mesh: THREE.Mesh,
    vertices: THREE.Vector3[],
    normals: THREE.Vector3[],
    faces: Array<{ vertices: number[]; normals: number[] }>,
    vertexOffset: number,
    normalOffset: number,
    scaleFactor: number
  ): void {
    const geometry = mesh.geometry
    const positionAttribute = geometry.attributes.position
    const normalAttribute = geometry.attributes.normal
    
    if (!positionAttribute) {
      throw new OBJExportError('Mesh geometry missing position attribute')
    }
    
    // Extract vertices
    const tempVertex = new THREE.Vector3()
    for (let i = 0; i < positionAttribute.count; i++) {
      tempVertex.fromBufferAttribute(positionAttribute, i)
      tempVertex.applyMatrix4(mesh.matrixWorld)
      tempVertex.multiplyScalar(scaleFactor)
      vertices.push(tempVertex.clone())
    }
    
    // Extract normals
    if (normalAttribute) {
      const tempNormal = new THREE.Vector3()
      const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld)
      
      for (let i = 0; i < normalAttribute.count; i++) {
        tempNormal.fromBufferAttribute(normalAttribute, i)
        tempNormal.applyMatrix3(normalMatrix).normalize()
        normals.push(tempNormal.clone())
      }
    }
    
    // Extract faces
    if (geometry.index) {
      // Indexed geometry
      const index = geometry.index
      for (let i = 0; i < index.count; i += 3) {
        const face = {
          vertices: [
            index.getX(i) + vertexOffset,
            index.getX(i + 1) + vertexOffset,
            index.getX(i + 2) + vertexOffset
          ],
          normals: normalAttribute ? [
            index.getX(i) + normalOffset,
            index.getX(i + 1) + normalOffset,
            index.getX(i + 2) + normalOffset
          ] : []
        }
        faces.push(face)
      }
    } else {
      // Non-indexed geometry
      for (let i = 0; i < positionAttribute.count; i += 3) {
        const face = {
          vertices: [
            i + vertexOffset,
            i + 1 + vertexOffset,
            i + 2 + vertexOffset
          ],
          normals: normalAttribute ? [
            i + normalOffset,
            i + 1 + normalOffset,
            i + 2 + normalOffset
          ] : []
        }
        faces.push(face)
      }
    }
  }
  
  /**
   * Create download blob for OBJ file
   */
  static createDownloadBlob(mesh: THREE.Group, params: ExportParams): { blob: Blob; filename: string } {
    const objContent = this.exportToOBJ(mesh, params)
    const blob = new Blob([objContent], { type: 'text/plain;charset=utf-8' })
    const filename = params.filename.endsWith('.obj') ? params.filename : `${params.filename}.obj`
    
    return { blob, filename }
  }
  
  /**
   * Generate material file (.mtl) content
   */
  static generateMTL(): string {
    return `# Material file for Dot Art 3D Converter
# Generated automatically

newmtl DotArtMaterial
Ka 0.200000 0.200000 0.200000
Kd 0.533333 0.533333 0.533333
Ks 0.100000 0.100000 0.100000
Ns 10.000000
Ni 1.000000
d 1.000000
illum 2
`
  }
}